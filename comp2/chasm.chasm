# See code_styling.txt for code styling information

# fun compile_line 1
define x
    # Pop the pointer
    pop

    # Save current string
    pop
    setvar S

    # Trim spaces from the start of the string
    inline $S m R0 0ff2 -- !:
    inline     $S 1 =S
    inline     $S m R0 0ff2 -- !
    end

    # If this string starts with '#', skip the whole thing
    inline $S m R0 0ff5 -- !?
        # Increment pointer until it reaches the end of this string
    inline     $S m :
    inline         $S 1 =S $S m
        end
    end

    # Compare this string with each of the saved strings

    # 'push'
    inline $S > rA > F= ?
        # ')'
    inline     0ffb M
    end

    # 'pop'
    inline $S > rB > F= ?
        # '<'
    inline     0ffff M
    end

    # 'if'
    inline $S > rC > F= ?
        # '?'
    inline     0ffff3 M
    end

    # 'while'
    inline $S > rD > F= ?
        # ':'
    inline     0fffd M
    end

    # 'end'
    inline $S > rE > F= ?
        # ';'
    inline     0fffe M
    end

    # 'memadd'
    inline $S > rF > F= ?
        # 'M'
    inline     0fffff2 M
    end

    # 'memget'
    inline $S > rG > F= ?
        # 'm'
    inline     0fffffff4 M
    end

    # 'print '
    inline $S > rH > Fs ?
        # 'print d'
    inline     $S 6 m R0 0ffffffa -- !?
            # 'p'
    inline         0fffffff7 M
        end

        # 'print c'
    inline     $S 6 m R0 0ffffff9 -- !?
            # 'P'
    inline         0fffff5 M
        end

        # 'print s'
    inline     $S 6 m R0 0fffffffa -- !?
            # 'm'
    inline         0fffffff4 M
            # 'P'
    inline         0fffff5 M
        end
    end

    # 'println '
    inline $S > rI > Fs ?
        # 'println d'
    inline     $S 8 m R0 0ffffffa -- !?
            # 'p'
    inline         0fffffff7 M
        end

        # 'println c'
    inline     $S 8 m R0 0ffffff9 -- !?
            # 'P'
    inline         0fffff5 M
        end

        # 'println s'
    inline     $S 8 m R0 0fffffffa -- !?
            # 'm'
    inline         0fffffff4 M
            # 'P'
    inline         0fffff5 M
        end

        # println is exactly the same as print, but `>aP<` is pushed to the
        # end to suffix a newline

        # '>'
    inline     0ffff2 M
        # 'a'
    inline     0ffffff7 M
        # 'P'
    inline     0fffff5 M
        # '<'
    inline     0ffff M
    end

    # 'memset'
    inline $S > rJ > F= ?
        # 'm'
    inline     0fffffff4 M
        # 'S'
    inline     0fffff8 M
    end

    # 'set'
    inline $S > rK > Fs ?
        # '0'
    inline     0fff3 M
        # Add the number after 'set ' (including the space)
        # (convert to integer, then save as a Char num)
        # 'set num'
    inline     $S 4 > FI > Fi
    end

    # 'ch'
    inline $S > rL > Fs ?
        # '0'
    inline     0fff3 M
        # Add the number after 'ch ' (including the space)
        # (as a Char num)
        # 'ch num'
    inline     $S 3 m > Fi
    end

    # 'add'
    inline $S > rM > Fs ?
        # Add the expression after 'add ' (including the space)
        # 'add num'
    inline     $S 4 > FX

        # '++'
    inline     0ffd MM
    end

    # 'sub'
    inline $S > rN > Fs ?
        # Add the expression after 'sub ' (including the space)
        # 'sub num'
    inline     $S 4 > FX

        # '--'
    inline     0fff MM
    end

    # 'mul'
    inline $S > rO > Fs ?
        # Add the expression after 'mul ' (including the space)
        # 'mul num'
    inline     $S 4 > FX

        # '**'
    inline     0ffc MM
    end

    # 'div'
    inline $S > rP > Fs ?
        # Add the expression after 'div ' (including the space)
        # 'div num'
    inline     $S 4 > FX

        # '//'
    inline     0fff2 MM
    end

    # 'exit'
    inline $S > rQ > F= ?
        # 'q'
    inline     0fffffff4 M
    end

    # 'setvar'
    inline $S > rR > Fs ?
        # '='
    inline     0ffff1 M
        # Add the letter after 'setvar ' (including the space)
    inline     $S 7 m M
    end

    # 'setreg'
    inline $S > rS > Fs ?
        # 'R'
    inline     0fffff7 M
        # Add the letter after 'setreg ' (including the space)
    inline     $S 7 m M
    end

    # 'getvar'
    inline $S > rT > Fs ?
        # '$'
    inline     0ff6 M
        # Add the letter after 'getvar ' (including the space)
    inline     $S 7 m M
    end

    # 'getreg'
    inline $S > rU > Fs ?
        # 'r'
    inline     0fffffff9 M
        # Add the letter after 'getreg ' (including the space)
    inline     $S 7 m M
    end

    # 'define'
    inline $S > rV > Fs ?
        # 'F'
    inline     0ffffa M
        # Add the letter after 'define ' (including the space)
    inline     $S 7 m M
    end

    # 'call'
    inline $S > rW > Fs ?
        # Function calling differs from function defining in that the pointer
        # is saved to the stack and retrieved from the stack before and after
        # function calling, respectively.

        # '>'
    inline     0ffff2 M
        # 'F'
    inline     0ffffa M
        # Add the letter after 'call ' (including the space)
    inline     $S 5 m M
        # '<'
    inline     0ffff M
    end

    # 'ptr'
    inline $S > rX > Fs ?
        # Define a pointer to an array of ints with a length equal to this
        # instruction's argument

        # 'm'
    inline     0fffffff4 M
        # 's'
    inline     0fffffffa M
        # '>'
    inline     0ffff2 M

        # Add the number after 'ptr ' (including the space)
        # Also add one to that number, because the pointer should have the
        # length specified, plus a null byte at the end
    inline     $S 4 > FI 1 > Fi

        # ':'
    inline     0fffd M

        # '>'
    inline     0ffff2 M
        # 'M'
    inline     0fffff2 M
        # '<'
    inline     0ffff M

        # '-'
    inline     0fff M
        # '1'
    inline     0fff4 M
        # '+'
    inline     0ffd M
        # ';'
    inline     0fffe M

        # '<'
    inline     0ffff M
    end

    # "'" || '"'
    inline $S m R0 0ff9 -- ! >
    inline $S m R0 0ff4 -- ! R0 < | ?
        # Save starting quote to put at the end
    inline     $S m >

    inline     $S m :
    inline         $S m M
    inline         $S 1 =S $S m
        end

        # Fetch starting quote to put at the end of this string, as long as the
        # string hasn't already been ended
        # (Ending quotes are optional)
    inline     $S -1+ m R0 ( -- ?
    inline         < M
        end
    end

    # 'and'
    inline $S > rY > Fs ?
        # Add the expression after 'and ' (including the space)
        # 'and num'
    inline     $S 4 > FX

        # '&'
    inline     0ff8 M
    end

    # 'or'
    inline $S > rZ > Fs ?
        # Add the expression after 'or ' (including the space)
        # 'or num'
    inline     $S 3 > FX

        # '|'
    inline     0ffffffff4 M
    end

    # 'inline'
    inline $S > rz > Fs ?
        # Add everything after 'inline ' (including the space)
    inline     $S 7 =S

    inline     $S m :
            # Add character
    inline         $S m M

            # Increment pointer
    inline         $S 1 =S
    inline         $S m
        end
    end

    # Increment pointer until it reaches the next string in the list
    inline $S m :
    inline     $S 1 =S $S m
    end

    # Push new string pointer (+1) back into the stack
    getvar S
    add 1
    push

    # Push empty pointer back onto stack
    set 0
    push
end


# fun compile_expression 1
define X
    # Get pointer to expression and save it
    inline <=A

    # Always begin an expression with '>' to preserve the pointer
    # '>'
    inline 0ffff2 M

    # If first letter is a digit, convert to int and push value as a Char num
    # A > 47 && A < 58
    inline 0fff2 R0 $A m } >
    inline 0fffd R0 $A m { R0 < & ?
        # Convert to int and push value as a Char num
        inline $A > FI > Fi
    end

    # If first letter is 'r', get the value from the given register name
    # A == 'r'
    inline 0fffffff9 R0 $A m -- !?
        # Get the value from the given register name
        # 'r'
        inline 0fffffff9 M
        inline $A 1 m M
    end

    # If first letter is '$', get the value from the given variable name
    # A == '$'
    inline 0ff6 R0 $A m -- !?
        # Get the value from the given variable name
        # '$'
        inline 0ff6 M
        inline $A 1 m M
    end

    # Always push the compiled result of an expression into r0

    # 'R'
    inline 0fffff7 M
    # '0'
    inline 0fff3 M

    # Always end an expression with '<' to retrieve the pointer
    # '<'
    inline 0ffff M
end


# fun startswith 2
define s
    # r1 is prefix
    # r2 is string to check prefix against

    # Save both string pointers to r1 and r2
    inline < R1
    inline < R2

    # Equal? (Starts true)
    inline 01=E

    # Compare string equality
    inline r1 m :
        # If !equal
        inline r1 m R0
        inline r2 m -- ?
            # Set unequal
            inline 0=E
        end

        # Increment pointers
        inline r1 1 R1
        inline r2 1 R2

        inline r1 m
    end

    # Stop at the end of the shortest string because this function is only
    # checking whether a string starts with another

    inline $E
end


# fun push_int_as_charnum 1
define i
    # Push an integer into compiled data as a Char num
    # Example: 32 -> ff2

    inline <=A

    # While num > 14
    inline 0e R0 $A } :
        # Add 'f' to compiled data
        inline 0ffffffc M

        # num -= 15
        inline $A -f+ =A
    
        # While num > 14
        inline 0e R0 $A }
    end

    # Now check the remaining value and add the final character

    # 14 -> 'e'
    inline $A -e+ !?
        # Add 'e' to compiled data
        inline 0ffffffb M
    end

    # 13 -> 'd'
    inline $A -d+ !?
        # Add 'd' to compiled data
        inline 0ffffffa M
    end

    # 12 -> 'c'
    inline $A -c+ !?
        # Add 'c' to compiled data
        inline 0ffffff9 M
    end

    # 11 -> 'b'
    inline $A -b+ !?
        # Add 'b' to compiled data
        inline 0ffffff8 M
    end

    # 10 -> 'a'
    inline $A -a+ !?
        # Add 'a' to compiled data
        inline 0ffffff7 M
    end

    # For any remaining numbers, simply add '0' (48) and append to compiled data

    # If num < 10
    # (make sure num isn't 0)
    inline 0a R0 $A { R0
    inline $A & ?
        # Add '0' (48) to number and add to compiled data
        inline $A fff3 M
    end
end


# fun toint 1
define I
    # Convert a string pointer to an integer

    # Multiplier
    inline 01=M

    # Pointer
    inline <=A

    # Result num
    inline 0=B

    # Start pointer
    inline $A=C

    # Increment A until a null byte is reached
    inline $A m :
        inline $A 1 =A
        inline $A m
    end

    # Decrement A once
    inline $A -1+ =A

    # While A > C - 1 (A >= C)
    inline $C -1+ R0 $A } :
        # B += (*A - '0') * M
        inline $A m -fff3+ R0 $M ** R0 $B ++ =B

        # M *= 10
        inline $M R0 0a ** =M

        # Decrement A
        inline $A -1+ =A

        # Loop condition
        inline $C -1+ R0 $A }
    end

    inline $B
end


# fun strcmp 2
define =
    # Pop pointer and remove it
    # pop

    # Save both string pointers to A and B
    pop
    setvar A
    pop
    setvar B

    # Equal? (Starts true)
    set 1
    setvar E

    # Condition for while loop
    getvar A
    memget
    setreg 0

    getvar B
    memget
    and r0

    # Compare string equality
    while
        # If !equal
        getvar A
        memget
        setreg 0

        getvar B
        memget
        sub r0
        if
            # Set unequal
            set 0
            setvar E
        end

        # Condition for while loop + increment both string pointers
        getvar A
        add 1
        setvar A
        memget
        setreg 0

        getvar B
        add 1
        setvar B
        memget
        and r0
    end

    # If either string still has bytes remaining, set unequal
    getvar A
    memget
    if
        set 0
        setvar E
    end

    getvar B
    memget
    if
        set 0
        setvar E
    end

    # Return equal
    getvar E
    # push
end


# Get argc and argv
inline @

# Keep argc in $v
pop
setvar v

# Clear first two arguments
pop
pop

# Open file (third argument)
pop
inline o

# If the file wasn't opened properly (ptr != 0), stop the code execution
if
    exit
end

# Save a whole heap of strings for later
'push'
setreg A
'pop'
setreg B
'if'
setreg C
'while'
setreg D
'end'
setreg E
'memadd'
setreg F
'memget'
setreg G
'print '
setreg H
'println '
setreg I
'memset'
setreg J
'set '
setreg K
'ch '
setreg L
'add '
setreg M
'sub '
setreg N
'mul '
setreg O
'div '
setreg P
'exit'
setreg Q
'setvar '
setreg R
'setreg '
setreg S
'getvar '
setreg T
'getreg '
setreg U
'define '
setreg V
'call '
setreg W
'ptr '
setreg X
'and '
setreg Y
'or '
setreg Z
'inline '
setreg z

# Pointer to tokenised code
inline ms
push

# Number of lines tokenised (starts at 1)
set 1
setvar i

# Tokenisation
inline ,
while
    # Save current character into c
    setvar c
    print c

    # Replace newlines with null bytes
    getvar c
    sub 10
    inline !
    if
        # Add null byte to memory
        set 0
        memadd

        # Increment line count
        getvar i
        add 1
        setvar i
    end

    # Push all other characters into memory as normal
    getvar c
    sub 10
    if
        # Add character to memory
        getvar c
        memadd
    end

    # Get next character
    inline ,
end

exit

# Push null byte to signify the end of the final string
set 0
memadd

# Pointer to compiled data
inline ms
setreg !

# Compilation
getvar i
while
    # Compile current string
    call x

    # Decrement counter
    getvar i
    sub 1
    setvar i
end

# Suffix compiled data with a null byte
set 0
memadd

set 0
println c

# Set file descriptor to the output file

# File name
'output-chasm.txt'

# Open the file for writing
inline O

# Write text to file
'# Program compiled with CharInterpreter/comp2/chasm.chasm'
inline m.

# Newline
inline 0a.

# Write compiled data to file
getreg !
inline m.

# Newline
inline 0a.
